#' Distance to group centroid
#'
#' `distance_to_centroid` calculates the distance of each relocation to the
#' centroid of the spatiotemporal group identified by `group_pts`. The
#' function expects a `data.table` with relocation data appended with a
#' `group` column from `group_pts` and centroid columns from
#' `centroid_group`. Relocation data should be in planar coordinates
#' provided in two columns representing the X and Y coordinates.
#'
#' The `DT` must be a `data.table`. If your data is a
#' `data.frame`, you can convert it by reference using
#' [data.table::setDT()] or by reassigning using
#' [data.table::data.table()].
#'
#' This function expects a `group` column present generated with the
#' `group_pts` function and centroid coordinate columns generated with the
#' `centroid_group` function. The `coords` and `group` arguments
#' expect the names of columns in `DT` which correspond to the X and Y
#' coordinates and group columns. The `return_rank` argument controls if
#' the rank of each individual's distance to the group centroid is also
#' returned. The `ties.method` argument is passed to
#' `data.table::frank`, see details at
#' [`?data.table::frank()`][data.table::frank].
#'
#' The `crs` argument expects a character string or numeric defining the
#' coordinate reference system to be passed to [sf::st_crs]. For example, for
#' UTM zone 36S (EPSG 32736), the crs argument is `crs = "EPSG:32736"` or
#' `crs = 32736`. See <https://spatialreference.org> for a list of EPSG codes.
#'
#' @param DT input data.table with centroid columns generated by eg.
#'   `centroid_group`
#' @param group group column name, generated by `group_pts`, default
#'   'group'
#' @param return_rank logical if rank distance should also be returned, default
#'   FALSE
#' @param ties.method see [`?data.table::frank()`][data.table::frank]
#' @inheritParams group_pts
#' @inheritParams direction_step
#'
#' @return `distance_to_centroid` returns the input `DT` appended with a
#'   `distance_centroid` column indicating the distance to the group centroid
#'   and, optionally, a `rank_distance_centroid` column indicating the within
#'   group rank distance to the group centroid (if `return_rank = TRUE`). The
#'   distance is returned in the units of the crs
#'   (`units(st_crs(crs)$SemiMajor)`). A value of 0 is returned when the
#'   coordinates of the focal individual equal the coordinates of the centroid.
#'
#'   The underlying distance function ([sf::st_distance]) uses different
#'   distance measures depending on the input `crs` and the option returned by
#'   [sf::sf_use_s2]. See more details under `?sf_distance`.
#'
#'   A message is returned when `distance_centroid` and optional
#'   `rank_distance_centroid` columns already exist in the input `DT`,
#'   because they will be overwritten.
#'
#'   See details for appending outputs using modify-by-reference in the
#'   [FAQ](https://docs.ropensci.org/spatsoc/articles/faq.html).
#'
#' @export
#' @family Distance functions
#' @family Centroid functions
#' @seealso [centroid_group], [group_pts], [sf::st_distance()]
#' @references
#' See examples of using distance to group centroid:
#'  * \doi{doi:10.1016/j.anbehav.2021.08.004}
#'  * \doi{doi:10.1111/eth.12336}
#'  * \doi{doi:10.1007/s13364-018-0400-2}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#' \dontshow{data.table::setDTthreads(1)}
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Spatial grouping with timegroup
#' group_pts(DT, threshold = 5, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup')
#'
#' # Calculate group centroid
#' centroid_group(DT, coords = c('X', 'Y'), group = 'group', na.rm = TRUE)
#'
#' # Calculate distance to group centroid
#' distance_to_centroid(
#'   DT,
#'   coords = c('X', 'Y'),
#'   group = 'group',
#'   crs = 32736,
#'   return_rank = TRUE
#' )
distance_to_centroid <- function(
    DT = NULL,
    coords = NULL,
    group = 'group',
    crs = NULL,
    return_rank = FALSE,
    ties.method = NULL) {

  # Due to NSE notes in R CMD check
  distance_centroid <- rank_distance_centroid <- NULL

  assert_not_null(DT)
  assert_is_data_table(DT)

  if (is.null(crs)) {
    crs <- sf::NA_crs_
  }
  assert_are_colnames(DT, coords)
  assert_length(coords, 2)
  assert_col_inherits(DT, coords, 'numeric')

  assert_not_null(return_rank)

  if ('distance_centroid' %in% colnames(DT)) {
    message('distance_centroid column will be overwritten by this function')
    data.table::set(DT, j = 'distance_centroid', value = NULL)
  }
  out <- 'distance_centroid'

  xcol <- data.table::first(coords)
  ycol <- data.table::last(coords)
  pre <- 'centroid_'
  centroid_xcol <- paste0(pre, xcol)
  centroid_ycol <- paste0(pre, ycol)
  centroid_coords  <- c(centroid_xcol, centroid_ycol)

  assert_are_colnames(DT, centroid_coords, ', did you run centroid_group?')
  assert_col_inherits(DT, centroid_coords, 'numeric')

  DT[, distance_centroid := calc_distance(
    x_a = .SD[[xcol]],
    y_a = .SD[[ycol]],
    x_b = .SD[[centroid_xcol]],
    y_b = .SD[[centroid_ycol]],
    crs = crs
  )]

    if (out %in% colnames(DT)) {
      message(out, ' column will be overwritten by this function')
      data.table::set(DT, j = out, value = NULL)
    }

    DT[, c(out) := calc_distance(
  if (return_rank) {
    assert_not_null(group)
    assert_are_colnames(DT, group, ', did you run group_pts?')

    if ('rank_distance_centroid' %in% colnames(DT)) {
      message(
        'rank_distance_centroid column will be overwritten by this function'
      )
      data.table::set(DT, j = 'rank_distance_centroid', value = NULL)
    }

    DT[, rank_distance_centroid :=
         data.table::frank(distance_centroid,  ties.method = ties.method),
       by = c(group)]
  }
  return(DT[])
}

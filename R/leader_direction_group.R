#' Leadership along group direction
#'
#' Given the mean direction of a group of individuals,
#' `leader_direction_group` shifts the coordinate system to a new origin at
#' the group centroid and rotates the coordinate system by the mean direction to
#' return each individual's position along the mean direction, representing
#' leadership in terms of the front-back position in each group's mean
#' direction.
#'
#' The function expects a `data.table` with relocation data appended with a
#' `group_direction` column from `direction_group` and group centroid
#' columns from `centroid_group`. Relocation data should be in two columns
#' representing the X and Y coordinates.
#'
#' The `DT` must be a `data.table`. If your data is a
#' `data.frame`, you can convert it by reference using
#' [data.table::setDT()] or by reassigning using
#' [data.table::data.table()].
#'
#' The `group_direction` argument expects the names of columns in `DT`
#' which correspond to the mean group direction generated by
#' `direction_group`. The mean group direction column is expected in units
#' of radians. The `coords` arguments expects the names of columns in
#' `DT` which correspond to the X and Y coordinate columns. The
#' `return_rank` argument controls if the rank of each individual's
#' distance to the group centroid is also returned. If `return_rank` is
#' TRUE, the `group` argument is required to specify the group column
#' generated by `group_pts`. The `ties.method` argument is passed to
#' `data.table::frank`, see details at
#' [`?data.table::frank()`][data.table::frank].
#'
#' @return `leader_direction_group` returns the input `DT` appended
#'   with a `position_group_direction` column indicating the position along
#'   the group direction in the units of the crs and, optionally when
#'   `return_rank = TRUE`, a `rank_position_group_direction` column
#'   indicating the ranked position along the group direction.
#'
#'   A message is returned when `position_group_direction` or
#'   `rank_position_group_direction` columns already exist in the input
#'   `DT`, because they will be overwritten.
#'
#'   See details for appending outputs using modify-by-reference in the
#'   [FAQ](https://docs.ropensci.org/spatsoc/articles/faq.html).
#'
#' @param DT input data.table with group direction columns generated by
#'   `direction_group` and centroid columns generated by
#'   `centroid_group`
#' @inheritParams distance_to_centroid
#' @inheritParams group_pts
#' @param group_direction group_direction column name generated using
#'   `direction_group`, default 'group_direction'
#'
#' @export
#' @seealso `direction_group`, `centroid_group`
#' @family Leadership functions
#' @family Direction functions
#'
#' @references
#' See examples of measuring leadership along group direction (also called
#' forefront index):
#'  * \doi{doi:10.1371/journal.pone.0036567}
#'  * \doi{doi:10.1111/jfb.15315}
#'  * \doi{doi:10.1098/rspb.2021.0839}
#'
#' @examples
#' # Load data.table
#' library(data.table)
#' \dontshow{data.table::setDTthreads(1)}
#'
#' # Read example data
#' DT <- fread(system.file("extdata", "DT.csv", package = "spatsoc"))
#'
#' # (Subset example data to reduce example run time)
#' DT <- DT[year(datetime) == 2016]
#'
#' # Cast the character column to POSIXct
#' DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]
#'
#' # Temporal grouping
#' group_times(DT, datetime = 'datetime', threshold = '20 minutes')
#'
#' # Spatial grouping with timegroup
#' group_pts(DT, threshold = 50, id = 'ID',
#'           coords = c('X', 'Y'), timegroup = 'timegroup')
#'
#' # Calculate direction at each step
#' direction_step(
#'   DT = DT,
#'   id = 'ID',
#'   coords = c('X', 'Y'),
#'   crs = 32736
#' )
#'
#' # Calculate group centroid
#' centroid_group(DT, coords = c('X', 'Y'))
#'
#' # Calculate group direction
#' direction_group(DT)
#'
#' # Calculate leader in terms of position along group direction
#' leader_direction_group(DT, coords = c('X', 'Y'))
leader_direction_group <- function(
    DT = NULL,
    group_direction = 'group_direction',
    coords = NULL,
    group = 'group',
    geometry = 'geometry',
    return_rank = FALSE,
    ties.method = 'average') {
  # Due to NSE notes
  position_group_direction <- rank_position_group_direction <- NULL

  assert_not_null(DT)
  assert_is_data_table(DT)

  if (is.null(coords)) {

  } else {
    assert_not_null(coords)
    assert_are_colnames(DT, coords)
    assert_length(coords, 2)

    xcol <- data.table::first(coords)
    ycol <- data.table::last(coords)

    centroid_xcol <- paste0('centroid_', gsub(' ', '', xcol))
    centroid_ycol <- paste0('centroid_', gsub(' ', '', ycol))

    check_cols <- c(group_direction, centroid_xcol, centroid_ycol)
    assert_are_colnames(DT, check_cols)

    assert_col_inherits(DT, coords, 'numeric')
    assert_col_inherits(DT, centroid_xcol, 'numeric')
    assert_col_inherits(DT, centroid_ycol, 'numeric')

    assert_not_null(return_rank)

    if ('position_group_direction' %in% colnames(DT)) {
      message(
        'position_group_direction column will be overwritten by this function'
      )
      data.table::set(DT, j = 'position_group_direction', value = NULL)
    }

    assert_col_radians(DT, 'group_direction', ', did you use direction_group?')

    DT[, position_group_direction :=
         cos(units::drop_units(.SD[[1]])) * (.SD[[2]] - .SD[[4]]) +
         sin(units::drop_units(.SD[[1]])) * (.SD[[3]] - .SD[[5]]),
       by = .I,
       .SDcols = c(group_direction, xcol, ycol, centroid_xcol, centroid_ycol)]

    if (return_rank) {
      rank_col <- 'rank_position_group_direction'
      if (rank_col %in% colnames(DT)) {
        message(
          paste0(rank_col, ' column will be overwritten by this function')
        )
        data.table::set(DT, j = 'rank_position_group_direction', value = NULL)
      }

      assert_not_null(group)
      assert_are_colnames(DT, group, ', did you run group_pts?')

      DT[, rank_position_group_direction :=
           data.table::frank(-position_group_direction,
                             ties.method = ties.method),
         by = c(group)]
    }
  }



  return(DT[])
}
